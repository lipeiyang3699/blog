<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>沛洋的博客－blog by lipeiyang3699</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">沛洋的博客－blog</h1>
      <h2 class="project-tagline">沛洋的博客</h2>
      <a href="https://github.com/lipeiyang3699/blog" class="btn">View on GitHub</a>
      <a href="https://github.com/lipeiyang3699/blog/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/lipeiyang3699/blog/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>javascript闭包的探索</p>

<hr>

<pre><code>在网站上看到一段代码，引起了对js闭包的探讨
   var result=[];
   function foo(){
            var i= 0;
            for (;i&lt;3;i=i+1){
                    result[i]=function(){
                            alert(i)；
                }
        }
};
    foo();
针对如上代码，最终输出内容为3，即闭包中所记录的自由变量，只是对这个变量的一个引用，而非变量的值，当这个值被改变了，闭包里获得到的变量值，也会被改变。
解决办法为让内部函数在循环创建时立即执行，并且捕捉当前的索引值，然后记录在自己的一个本地变量里，然后利用返回函数的方法，重写内部函数，让下一次调用的时候，返回本地变量的值，修改后的代码如下：

    var result=[];
function foo(){
    var i= 0;
    for (;i&lt;3;i=i+1){
        result[i]=(function(j){
            return function(){
                alert(j);
            };
        })(i);
        }
};

angularJS中的一个典型场景，代码如下：
function($scope, $ele, $attrs){
        var attrs = $attrs;
        debugger;
        if(undefined === $attrs.event){
            $ele.bind("click", function(){
                debugger;
                $scope.name = "123"; //1
                $ele; //2
            })
        }

    }
倘若没有1和2处的代码，通过debugger方式调试时，查询$scope和$ele全部为异常，说明这两个变量都被回收了。但是当放开1处的代码，仅注释2处的代码，在执行过程中通过断点调试就会发现$scope有值，而$ele没有内容，说明$ele被回收了，但其实当前函数中也并没有$scope的定义，而$scope却有值。由此便可以引申出javascript中关于闭包的两个特点，作用域链和垃圾回收机制。
首先看一下垃圾回收，当我们把1和2处的代码都注释了的时候，当执行了内部函数时，由于内部函数当前不依赖我们注释掉的那两个变量，所以这些变量就被垃圾回收器回收了，因而当我们在debugger模式下查看时就会抛出异常。而当我们只注释代码2的时候，在断点处查看$scope时回发现一切正常，但是查看$ele时就会有异常，由于内部没有使用$ele，所以就被回收了，而$scope则没有被回收。
接下来看一下作用域链，在没有注释代码的情况下，当我们触发bind事件时，为什么当前函数没有定义$scope和$ele，却可以取到值，原因很简单，当当前作用域下没有这个变量值的时候，就会顺着函数向他的上级作用域查看，而上级作用域就是父级函数，层层向上，直至最外层，还没有的话就是undefined。
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/lipeiyang3699/blog">沛洋的博客－blog</a> is maintained by <a href="https://github.com/lipeiyang3699">lipeiyang3699</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
