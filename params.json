{
  "name": "沛洋的博客－blog",
  "tagline": "沛洋的博客",
  "body": "javascript闭包的探索\r\n\r\n\r\n***\r\n\r\n    在网站上看到一段代码，引起了对js闭包的探讨\r\n       var result=[];\r\n       function foo(){\r\n                var i= 0;\r\n                for (;i<3;i=i+1){\r\n                        result[i]=function(){\r\n                                alert(i)；\r\n        \t        }\r\n    \t\t}\r\n\t};\r\n        foo();\r\n    针对如上代码，最终输出内容为3，即闭包中所记录的自由变量，只是对这个变量的一个引用，而非变量的值，当这个值被改变了，闭包里获得到的变量值，也会被改变。\r\n    解决办法为让内部函数在循环创建时立即执行，并且捕捉当前的索引值，然后记录在自己的一个本地变量里，然后利用返回函数的方法，重写内部函数，让下一次调用的时候，返回本地变量的值，修改后的代码如下：\r\n\t\r\n        var result=[];\r\n\tfunction foo(){\r\n    \tvar i= 0;\r\n    \tfor (;i<3;i=i+1){\r\n        \tresult[i]=(function(j){\r\n            \treturn function(){\r\n                \talert(j);\r\n            \t};\r\n        \t})(i);\r\n    \t\t}\r\n\t};\r\n\r\n\tangularJS中的一个典型场景，代码如下：\r\n\tfunction($scope, $ele, $attrs){\r\n\t\t\tvar attrs = $attrs;\r\n\t\t\tdebugger;\r\n\t\t\tif(undefined === $attrs.event){\r\n\t\t\t\t$ele.bind(\"click\", function(){\r\n\t\t\t\t\tdebugger;\r\n\t\t\t\t\t$scope.name = \"123\"; //1\r\n\t\t\t\t\t$ele; //2\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n    倘若没有1和2处的代码，通过debugger方式调试时，查询$scope和$ele全部为异常，说明这两个变量都被回收了。但是当放开1处的代码，仅注释2处的代码，在执行过程中通过断点调试就会发现$scope有值，而$ele没有内容，说明$ele被回收了，但其实当前函数中也并没有$scope的定义，而$scope却有值。由此便可以引申出javascript中关于闭包的两个特点，作用域链和垃圾回收机制。\r\n    首先看一下垃圾回收，当我们把1和2处的代码都注释了的时候，当执行了内部函数时，由于内部函数当前不依赖我们注释掉的那两个变量，所以这些变量就被垃圾回收器回收了，因而当我们在debugger模式下查看时就会抛出异常。而当我们只注释代码2的时候，在断点处查看$scope时回发现一切正常，但是查看$ele时就会有异常，由于内部没有使用$ele，所以就被回收了，而$scope则没有被回收。\r\n    接下来看一下作用域链，在没有注释代码的情况下，当我们触发bind事件时，为什么当前函数没有定义$scope和$ele，却可以取到值，原因很简单，当当前作用域下没有这个变量值的时候，就会顺着函数向他的上级作用域查看，而上级作用域就是父级函数，层层向上，直至最外层，还没有的话就是undefined。",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}